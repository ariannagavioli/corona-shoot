/* Network.s3d */


// PDU Definition Data exchange
#define TROOPER_KINEMATICS_PDU	1
#define SHOT_AMMO_PDU			2
#define GOT_SHOT_PDU 			3
#define WEAPON_PDU				4
#define WEAPON_SWITCH_PDU		5
#define JUMP_SCREAM_PDU			6
#define INJURIED_PDU			7

// PDU Definition Autentication
#define NAME_ME_PDU		99 	// Command to ask the server for a name
#define LIST_RQ_PDU		98	// Command to ask the server for a list of players
#define LIST_RM_PDU		97	// Command from the server to remove a client

class PDUClass {
	var msgPosition;	// PDU to send position
	var msgScore;		// PDU to send score
	var msgBullet;		// PDU to send bullets
	var msgInjuried;		//
	var msgEvent;		// pdu to send events 
	var command2;		// PDU for sending commands to the Server

	kinematics(pdu_type, pos, vel, angle);	// generate trooper position pdu
	event(event_type);
	Injuried(who, dammage);
};

function PDUClass::Injuried(who, dammage) {
	msgInjuried[2] = who;
	msgInjuried[3] = dammage;
}

function PDUClass::event(event_type) {
	msgEvent[0] = event_type;
}

function PDUClass::kinematics(pdu_type, pos, vel, angle) {
	msgPosition[0] = pdu_type;
	msgPosition[2] = pos[0];
	msgPosition[3] = pos[1];
	msgPosition[4] = pos[2];
	msgPosition[5] = vel;
	msgPosition[6] = 0;
	msgPosition[7] = angle;
}

function PDUClass::PDUClass(id) {
	// pdu to send a command to the server
	command2 = vector(2);
	command2[1] = id;

	// Position PDU
	msgPosition = vector(8);
	msgPosition[0] = TROOPER_KINEMATICS_PDU;
	msgPosition[1] = id;

	// Event PDU
	msgEvent = vector(3);
	msgEvent[0] = WEAPON_SWITCH_PDU;
	msgEvent[1] = id;
	msgEvent[2] = 1;
	// Score PDU
	// PDU_SCORE = vector(num_players);
	// PDU_SCORE[0] = PDU_SCORE;
	// PDU_SCORE[1] = id;

	// Bullet PDU
	// PDU_BULLET = vector(7);
	// PDU_BULLET[0] = PDU_BULLET

	// Injuried PDU
	msgInjuried = vector(4);
	msgInjuried[0] = INJURIED_PDU;
	msgInjuried[1] = id;
}

class Network {
	var m_id;
	var m_badass_name;
	var m_pdu;
	var channel;
	var dataRcv;
	var open;

	connectTCP(ip, port);
	receiveTCP(data);
	force_receiveTCP(data); // it does busy waiting to wait until have a response
	sendTCP(data);
	closeTCP();
};

function Network::connectTCP(ip, port) {
	channel = NetConnectTCP(ip, port, VR_NO_BLOCKING);
	open = true;
}

function Network::force_receiveTCP(data) {
	data = NULL;
	while(data == NULL)
		data = NetVarReceiveFromTCP(channel, "");
}

function Network::receiveTCP(data) {
	if (open)
		data = NetVarReceiveFromTCP(channel, "");
}

function Network::sendTCP(data) {
	if (open)
		NetVarSendToTCP(channel, data, "");
}

function Network::closeTCP() {
	if (open) {
		NetClose(channel);
		open = false;
	}
}

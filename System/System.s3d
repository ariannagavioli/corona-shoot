/* SYSTEM */
#ifndef SYSTEM_S3D
#define SYSTEM_S3D 

#include "../Player/Enemy.s3d"
#include "../Player/Myself.s3d"
#include "../Audio/AudioFXSystem.s3d"
#include "../Level/ResourcesManager.s3d"
#include "../RenderEntity/Console.s3d"

#define SYS_GRAVITY			9.8
#define SYS_DELTA_T			1.0 / 60

class System {
	// System components
	var audioFX;
	/* Render actions */
	drawTrooper(trooper, me);
	updateTrooper(trooper);
	showScoreTable(j, obj);
	showMyInfo(myAlias);
	drawResource(res, me);

	/* Physics */
	updateBullet(trooper, id, matrix);

	/* Human interaction */
	MoveTrooper(trooper, level);
	pointOfView(obj);
	selectWeapon(obj);
	reload(me);
	takePainkillers(me);
	showHelp();

	/* Network */
	sendKinematics(kinematics_owner, m_ses, obj);
	sendEvent(m_ses, obj);
};

function System::System() {
	audioFX = AudioFXSystem();
	ConsoleSetDefault();	
}

function system::showHelp() {
	if(KeyPressed(VK_ESCAPE)) 
		ConsolePlotHelp();
}

function System::reload(trooper) {
	if(KeyPressed("r") && trooper.ammo.readyToReload) {
		trooper.ammo.reload();
		trooper.ammo.readyToReload = false;
	}
}

function System::takePainkillers(trooper) {
	if (KeyPressed("h") && trooper.life.readyToTakePainkillers) {
		trooper.life.life = MAX_LIFE_POINTS;
		trooper.life.readyToTakePainkillers = false;
	}  
}

function System::drawResource(res, me) {
	var dst;
	for (var i = 0; i < res.length; i++) {
		dst = modulus(res.res[i].pos - me.m_kinematics.pos);
		
		if (dst < 10) 
			res.draw(i);

		if (dst < 1.5) {
			if (res.res[i].type == AMMO_BOX) {			
				ConsoleText(0.48, 0.53, "Press R to RELOAD");
				me.ammo.readyToReload = true;
			}

			if (res.res[i].type == FIRST_AID_KIT) {
				ConsoleText(0.47, 0.5, "Press H to Take Painkillers");
				me.life.readyToTakePainkillers = true;
			}
		}

	}
}

function System::shoot(trooper) {

	if(Mouse.ButtonL && trooper.ammo.life == 0 && trooper.ammo.bag() != 0) {
		var angleTmp = trooper.m_kinematics.angle * PI / 180.0;
		var direction = [sin(angleTmp), 0, cos(angleTmp)];
		trooper.ammo.m_kinematics.pos = trooper.m_kinematics.pos;
		trooper.ammo.life = 100;
		
		trooper.ammo.m_kinematics.pos[0] += -direction[2] * 0.2;
		trooper.ammo.m_kinematics.pos[2] += direction[0] * 0.2;
		trooper.ammo.m_kinematics.pos[1] += 1.3;
		trooper.ammo.m_kinematics.vel = trooper.ammo.life;
		trooper.ammo.m_kinematics.angle = angleTmp;
		// trooper.ammo.m_kinematics.pos = 
		trooper.ammo.m_kinematics.orientation = direction;
		trooper.ammo.decrease();
	}
}

function checkBulletHit(trooper, id) {
	var length = len(trooper);
	var d;
	for (var i = 0; i < length; ++i) {
		if ((i != id && (trooper[i].tagID.number > 0))) {
			d = modulus(trooper[i].m_kinematics.pos - trooper[id].ammo.m_kinematics.pos);
			if (d < 1.4) {
				trooper[i].hit = 100;
				trooper[i].life--;
				return true;
			}
		}
	}
	return false;
}

function System::updateBullet(troopers, id, matrix) {
	var me = troopers[id];
	if(me.ammo.life > 0) {
		me.ammo.life--;
		var tmpPos = me.ammo.updatePosition();
		var i = Floor(tmpPos[0]);
		var k = Floor(tmpPos[2]);

		var coll = checkBulletHit(troopers, id);


		if ((matrix[k][i] == "*") || coll) {
			me.ammo.life = 0;
			me.ammo.m_kinematics.vel = 0;
		} 
		else {
			me.ammo.m_kinematics.pos = tmpPos;
			me.ammo.m_kinematics.vel = me.ammo.life;
		}
	}
}


function System::sendEvent(m_ses, trooper) {
	/* Send weapon switch */
	if(trooper.weapon)
		m_ses.sendEvent(WEAPON_SWITCH_PDU);

	if(trooper.m_kinematics.just_jumped)
		m_ses.sendEvent(JUMP_SCREAM_PDU);
}

function System::showMyInfo(trooper) {
	// My Name
	ConsoleText(0.43, 0.9, "Welcome Back " + trooper.tagID.name);
	// My health
	ConsoleText(0.05, 0.10, "Health " + str(trooper.life.life));
	// My Ammution Available
	ConsoleText(0.05, 0.05, "Ammution " + trooper.ammo.getName() + " " + str(trooper.ammo.bag()));
}

function System::sendKinematics(kinematics_owner, m_ses, obj) {
	m_ses.sendKinematics(kinematics_owner, obj);
}

function System::showScoreTable(j, obj) {
	ConsoleText(0.05, 0.9 - 0.03*j, obj.tagID.name + "'s away from cure: " + str(obj.life.life));
}

function System::selectWeapon(trooper) {
	static var pressed = false;
	var pressed2 = KeyPressed("f"); 

	if((pressed == false) && (pressed2 == true)) {
		trooper.weapon = true;
		if (trooper.ammo.type == RAILGUN_T) trooper.ammo.type = ROCKETLAUNCHER_T;
		else trooper.ammo.type = RAILGUN_T;
	}
	pressed = pressed2;
}

function System::drawTrooper(trooper, me) {
	if (trooper.weapon) {
		trooper.drawable.weapon.toggle();
		trooper.weapon = false;
	} 

	if (trooper.m_kinematics.vel != 0) {
		trooper.drawable.draw(START_WALK_SWAT + trooper.drawable.frame);
		// audioFX.playSteps(trooper.m_kinematics, me.m_kinematics);
	}
	else 
		trooper.drawable.draw(0);
	
	trooper.drawable.setPosition(trooper.m_kinematics.pos, trooper.m_kinematics.angle);
	
	if(trooper.m_kinematics.just_jumped) {
		audioFX.playJump(trooper.m_kinematics, me.m_kinematics);
		trooper.m_kinematics.just_jumped = false;
	}

	if(trooper.ammo.life > 0) {
		if(trooper.ammo.life == 99)
			audioFX.playShoot(trooper.m_kinematics, me.m_kinematics);

		trooper.drawable.drawBullet(trooper.ammo.m_kinematics.pos, trooper.ammo.size());
	}
}

function System::MoveTrooper(trooper, level) {
	trooper.m_kinematics.prev_velocity = trooper.m_kinematics.vel;
	trooper.m_kinematics.vel = 0;

	if (KeyPressed("w"))
		trooper.m_kinematics.vel = trooper.m_kinematics.step_velocity;
	else if (KeyPressed("s"))
		trooper.m_kinematics.vel = -trooper.m_kinematics.step_velocity;

	if (KeyPressed("d")){
		trooper.m_kinematics.angle -= trooper.m_kinematics.step_angle;
		trooper.m_kinematics.angle = trooper.m_kinematics.angle % 360;
	}
    else if(KeyPressed("a")){
        trooper.m_kinematics.angle += trooper.m_kinematics.step_angle;
    	trooper.m_kinematics.angle = trooper.m_kinematics.angle % 360;  
    }
    
    /* Jump, only if not already jumping*/
	if(KeyPressed(VK_SPACE) && !trooper.m_kinematics.is_jumping) {
		trooper.m_kinematics.is_jumping = true;
		trooper.m_kinematics.just_jumped = true;			// Need this to play the jump sound
		trooper.m_kinematics.vertical_velocity = 4.5;
	}

    /* If player is jumping, update jump dynamics*/
    if(trooper.m_kinematics.is_jumping){
    	trooper.m_kinematics.vel = trooper.m_kinematics.prev_velocity;
    	var new_y = trooper.m_kinematics.pos[1] + trooper.m_kinematics.vertical_velocity * SYS_DELTA_T;
		trooper.m_kinematics.vertical_velocity -= SYS_GRAVITY * SYS_DELTA_T;
		
		var floor_distance = level.floorDistance([trooper.m_kinematics.pos[0], new_y, trooper.m_kinematics.pos[2]]);

		if (floor_distance <= 0) {						// if the player has landed on the floor / on a wall
			trooper.m_kinematics.is_jumping = false;
			new_y = new_y - floor_distance;
		}
		
		trooper.m_kinematics.pos[1] = new_y;
    }
    else {
    	var floor_distance = level.floorDistance([trooper.m_kinematics.pos[0], trooper.m_kinematics.pos[1], trooper.m_kinematics.pos[2]]);
    	
    	if (floor_distance > 0) {					// The player is falling, e.g. it steps away from a wall -> it falls on the ground, but doesn't jump
    		trooper.m_kinematics.vertical_velocity -= SYS_GRAVITY * SYS_DELTA_T;
    		var delta_fall = trooper.m_kinematics.vertical_velocity * SYS_DELTA_T;
    		if(abs(delta_fall) > floor_distance)
				trooper.m_kinematics.pos[1] -= floor_distance;
			else
				trooper.m_kinematics.pos[1] += delta_fall;
		}
		
		else {										// If player is not falling, reset the vertical velocity to 0
			trooper.m_kinematics.vertical_velocity = 0;
		}
    }
    
    var pos = Array(3);		// contains the next candidate position
    var ray = trooper.getBoundingRay();
    pos[0] = trooper.m_kinematics.pos[0] + trooper.m_kinematics.vel * sin(trooper.m_kinematics.angle / 180.0 * PI);
    pos[1] = trooper.m_kinematics.pos[1];
    pos[2] = trooper.m_kinematics.pos[2] + trooper.m_kinematics.vel * cos(trooper.m_kinematics.angle / 180.0 * PI);

	var x_left = pos[0] + ray;
	var x_right = pos[0] - ray;
	var z_up = pos[2] + ray;
	var z_bottom = pos[2] - ray;
	
	var xr_coll = level.wallCollision([x_right, trooper.m_kinematics.pos[1], trooper.m_kinematics.pos[2]]);
	var xl_coll = level.wallCollision([x_left, trooper.m_kinematics.pos[1], trooper.m_kinematics.pos[2]]);
	var zu_coll = level.wallCollision([trooper.m_kinematics.pos[0], trooper.m_kinematics.pos[1], z_up]);
	var zb_coll = level.wallCollision([trooper.m_kinematics.pos[0], trooper.m_kinematics.pos[1], z_bottom]);
	
	
	var angle = ( trooper.m_kinematics.angle + 360 );
	if(trooper.m_kinematics.vel < 0)		//angle the trooper looks at is the opposite wrt direction of movement
		angle += 180;
	angle = angle % 360;

	if( (!xr_coll && !xl_coll)				//No collision over x
		|| ( xr_coll && angle <= 180 )		//Collision on the right, but the player is moving left
		|| ( xl_coll && angle >= 180 ) )	//Collision on the left, but the player is moving right
    	trooper.m_kinematics.pos[0] = pos[0];	// x-component
    
    if( (!zu_coll && !zb_coll)								//No collision over z
    	|| ( zu_coll && angle >= 90 && angle <= 270 ) 		//Collision on the top, but player is moving down
    	|| ( zb_coll && (angle <= 90 || angle >= 270 ) ) )	//Collision on the bottom, but player is moving up
    	trooper.m_kinematics.pos[2] = pos[2];	// z-component
}

function System::updateTrooper(trooper) {
	if (trooper.m_kinematics.vel != 0 && !trooper.m_kinematics.is_jumping) {
		trooper.drawable.frame += 1;
		trooper.drawable.frame = trooper.drawable.frame % (END_WALK_SWAT - START_WALK_SWAT);
	}
}

function System::pointOfView(obj) {
 
	if (keyboard() == "v") {
		obj.cam.view = !obj.cam.view;
		obj.cam.cam.Free();					// it frees from setTarget;
	}


	/* 1st Person */
	if (obj.cam.view) {	
		obj.cam.pos = obj.m_kinematics.pos + [0, 1.3, 0];				//Camera position = player position with a height offset from the ground
		obj.cam.angle = obj.m_kinematics.angle + 180.0;
		obj.cam.angle = obj.cam.angle % 360;			
		obj.cam.cam.setRotation(obj.cam.angle, [0,-1,0]);				//Rotate the camera accordingly to the player rotation
	}
	/* 3rd Person */
	else {
		if(keyPressed(VK_UP) && obj.cam.offset > MIN_CAM_OFFSET)		//Getting closer to the trooper
			obj.cam.offset -= 0.1;
			
		if(keyPressed(VK_DOWN) && obj.cam.offset < MAX_CAM_OFFSET)		//Distantiating from the trooper
			obj.cam.offset += 0.1;
		
		obj.cam.pos[0] = obj.m_kinematics.pos[0] - obj.cam.offset * sin(obj.m_kinematics.angle * PI / 180.0);
		obj.cam.pos[1] = obj.m_kinematics.pos[1] + 2;
		obj.cam.pos[2] = obj.m_kinematics.pos[2] - obj.cam.offset * cos(obj.m_kinematics.angle * PI / 180.0);
		obj.cam.cam.setTarget(obj.m_kinematics.pos + [0, 1.6, 0]);
	}
	obj.cam.cam.setPosition(obj.cam.pos);
}

#endif

/* Include s3d symbols */
#include <Script3d.h>
#include <Camera.s3d.h>
#include <./Level/level.s3d>
#include <./Player/player.s3d>
#include <./Network/session.s3d>
#include <./System/System.s3d>
#include <./Manager/Manager.s3d>
/* Set global scene parameters */
SET SCENE_FOV  = 60;
SET SCENE_NEAR = 0.5;
SET SCENE_FAR  = 1000;

// TODO: put your global variables here

/* Camera globals */
var CamPos = [0.0, 5.0, 30.0]; 	// camera position

/* Light globals */
var Light0;
var PosL = [0.0, 10.0, 10.0];	// default light position


/* Function declarations */
function CameraMoveMouse();
function DrawGrid(col, size);

/* GLOBAL VARIABLES */
var curr_player;
var curr_level;
// var camera;

// Network
#define SERVER_IP 	"34.67.36.159" 	// Google VM
// #define SERVER_IP 	"192.168.43.100"	// Raspberry Pi
#define SERVER_PORT 80					// TCP Port
var m_session = Session();
var m_index;
var m_system;

// Participants
#define MAX_NUM_PLAYERS 20
var m_manager;

function OnDownload()
{
	// Download resources here;
	FileDownload("XVRResources.zip");
}

function OnInit(params)
{
	/* initialize camera */
	CameraGetCurrent().SetPosition(CamPos);

	/* initialize light */
	Light0 = CVmLight();
	Light0.SetPosition(PosL);
	Light0.SetDiffuse(1, 1, 1);
	Light0.Enable();	

	// Our initializations
	
	setFrameRate(60);
	
	curr_level = level();
	curr_level.init("level.txt");
	
	// curr_player = player();
	// curr_player.init();
	// curr_player.setPosition([2,0,2]);

	m_system = System();

	m_manager = Manager(MAX_NUM_PLAYERS);
	var successfulSignUp = false;
	// m_session = Session();
	m_session.connectTCP(SERVER_IP, SERVER_PORT);
	m_session.signUp(&successfulSignUp);
	// TODO: Window for server rejection
	// TODO: if (successfulSignUp) {
		 m_session.queryParticipants(&m_manager);
	// TODO: } else {
		// TODO: OutputLN("Server full");
	// TODO: }
	m_index = m_session.m_id - 1;
	m_manager.participants[m_index].initialSpawn(curr_level.matrix);
}



function OnFrame()
{
	/* manage camera */
	// CameraMoveMouse();

	SceneBegin();

	DrawGrid([0.5, 0.5, 0.5], 100);
	
	/* Debug camera view */
	// if(keypressed(VK_LCONTROL)){
	// 	curr_player.debug_mode();
	// }
	
	// if(curr_player.debug){
	// 	CameraMoveMouse();
	// }

	// curr_player.update();
	/* code */
	curr_level.draw();
	var j = 0;
	for (var i = 0; i < MAX_NUM_PLAYERS; ++i) {
		/* Just the troopers with id bigger than 0 */
		if (m_manager.participants[i].tagID.number > 0) {
			/* COMPULSARY SYSTEMS FOR MYSELF*/
			if (i == m_index) {
				m_system.showMyName(m_manager.participants[i]); 

				m_system.moveTrooper(m_manager.participants[i]);
				m_system.jump(m_manager.participants[i]);
				m_system.pointOfView(m_manager.participants[i]);
				m_system.selectWeapon(m_manager.Participants[i]);
				m_system.sendKinematics(TROOPER_KINEMATICS_PDU, &m_session, m_manager.Participants[i]);			
				m_system.sendEvent(&m_session, m_manager.Participants[i]);
			}

			m_system.updateTrooper(m_manager.participants[i]);
			// Our drawings
			m_system.drawTrooper(m_manager.participants[i]);
			m_system.showScoreTable(j, m_manager.participants[i]);
			j++;
		}
	}
	// // Draw all Participants
	// // playerCluster.drawEmAll();	
	// curr_player.draw();
	

	SceneEnd();
}



function DownloadReady(RequestID)
{
	// TODO
}



function OnTimer()
{
	// TODO:
	var recvData = NULL;
	m_session.receiveTCP(&recvData);
	if (recvData != NULL) {

		/* Updating enemies kinematics */
		if(recvData[0] == TROOPER_KINEMATICS_PDU) {
			var incoming_id = recvData[1] - 1;
			m_manager.participants[incoming_id].m_kinematics.pos[0] = recvData[2];
			m_manager.participants[incoming_id].m_kinematics.pos[1] = recvData[3];
			m_manager.participants[incoming_id].m_kinematics.pos[2] = recvData[4];
			m_manager.participants[incoming_id].m_kinematics.vel = recvData[5];
			m_manager.participants[incoming_id].m_kinematics.angle = recvData[7];
		}

		/* Switch enemy's weapon */
		if(recvData[0] == WEAPON_SWITCH_PDU) {
			var incoming_id = recvData[1] - 1;
			m_manager.participants[incoming_id].weapon = true;
		}

		/* Jumped event on the enemies */
		if(recvData[0] == JUMP_SCREAM_PDU) {
			var incoming_id = recvData[1] - 1;
			m_manager.participants[incoming_id].m_kinematics.just_jumped = true;	
		}

		/* Server says there's a new guy in town */
		if(recvData[0] == LIST_RQ_PDU) {
			var name;
			m_session.force_receiveTCP(&name);
			m_manager.addParticipant(recvData[2], name);
		}

		/* Server says one just left*/
		if(recvData[0] == LIST_RM_PDU) {
			m_manager.rmParticipant(recvData[2]);
		}
	}
}


function OnEvent(eventID, wparam, lparam){
	// TODO: put your events handling code here
}

function OnError(){
	// TODO: put your errors handling code here
}


function OnExit()
{
	// TODO: put your cleanup code here
	m_session.closeTCP();
}



// Camera manager (using mouse)
function CameraMoveMouse()
{	

	CameraMoveMouse_MBL_LC();

}



function DrawGrid(col, size)
{
	/* let's not mess up current OpenGL status */
	glPushAttrib(GL_LIGHTING_BIT | GL_LINE_BIT | GL_CURRENT_BIT);
	
	glLineWidth(1);
	glDisable(GL_LIGHTING);
	glColor(col);
	var max = size / 2.0;
	var min = -max;	
	var step = size / 10.0;
	
	glBegin(GL_LINES);
		for (var i = min; i <= max; i += step)
		{
			glVertex(i, 0, max);
			glVertex(i, 0, min);
			
			glVertex(max, 0, i);
			glVertex(min, 0, i);
		}
	glEnd();
	
	/* polite restoration of previous OpenGL status */
	glPopAttrib();
}
